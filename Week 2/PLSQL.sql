--CREATE A SEQUENCE
/*
CREATE OR REPLACE [Seq name]
MINVALUE[value]
MAXVALUE[value]
START WITH [value]
INCREMENT BY [value]
CACHE [value];*/
CREATE SEQUENCE MYTESTSEQ
MINVALUE 100
MAXVALUE 10000
START WITH 5000
INCREMENT BY -5
CACHE 20;

SELECT MYTESTSEQ.NEXTVAL FROM DUAL;
--INSERT INTO STUDENT(ID,NAME,SCHOOL_ID) VALUES (MYTESTSEQ.NEXTVAL,BOBBY,134);

--A VIEW TO A KILL
--A VIEW IS  A SAVED SELECT STATEMENT(BASICALLY)
CREATE OR REPLACE VIEW MYVIEW
AS SELECT TITLE AS A_LIST_OF_STUFF FROM ALBUM
UNION
SELECT NAME FROM ARTIST;

SELECT A_LIST_OF_STUFF FROM MYVIEW
WHERE A_LIST_OF_STUFF LIKE 'T%';--LIKE OR STARTS WITH T

--INDEX
--APPLY TO A COLUMN TO SPEED UP SEARCH BY ENFORCING A PHYSICAL
--IN-MEMORY ORDER OF ROWS
--SEARCHES BECOME FASTER, BUT INSERT/DELETE ARE SLOWED DOWN
--UNIQUE, PK AND FK CONSTRAINTS IMPLICITLY GENERATE INDICES
CREATE INDEX MYNEWINDEX
ON ALBUM(ARTISTID); 
/*CURSORS
VIEW STORED IN A LOCAL VARIABLE
A POINTER TO A SECTION OF A TABLE/RESULTSET
IT MUST BE OPENED
IT CAN BE LOOPED THROUGH
IT MUST BE CLOSED
EVERY SQL STATEMENT GENERATES A CURSOR- ALLOW PL/SQL
TO INTERACT W/ SQL
*IMPLICIT CURSORS*
-DQL
SELECT *  FROM POKEMON;
-SYSTEM REFERENCE CURSORS ARE ALREADY THERE FOR US TO USE
*EXPLICIT CURSORS*
CUR S = SELECT * FROM POKEMON;
SELECT ID FROM S;
GOOD FOR FORMATTING OUR OUTPUT
