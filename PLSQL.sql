--Create a sequence
/*
CREATE OR REPLACTE [SEQ NAME]
MINVALUE[VALUE]
MAXVALUE[VALUE]
START WITH [VALUE]
INCREMENT BY [VALUE]
CACHE [VALUE];
*/
CREATE SEQUENCE MYTESTSEQ
MINVALUE 100
MAXVALUE 10000 
START WITH 5000
INCREMENT BY -5
CACHE 20;

SELECT MYTESTSEQ.nextVAL FROM DUAL;
-- Using a sequence to insert a primary key
-- INSERT INTO STUDENT(ID,NAME,SCHOOL_ID) VALUES (MYTESTSEQ.NEXTVAL, BOBBY, 134)

-- A VIEW TO KILL
/*
A view is a saved select Statement
*/
CREATE OR REPLACE VIEW MYVIEW
AS SELECT TITLE AS A_LIST_OF_STUFF FROM ALBUM 
UNION SELECT NAME FROM ARTIST;

SELECT * FROM MYVIEW;

SELECT A_LIST_OF_STUFF FROM MYVIEW
WHERE A_LIST_OF_STUFF LIKE 'T%';-- LIKE OR STARTS WITH T

--INDEX APPLY TO A COLUMN TO SPEED UP SEARCH BY ENFORCING A PHYSICAL
--IN-MEMORY ORDER OF ROWS
--SEARCHES BECOME FASTER, BUT INSERT/DELETE ARE SLOWED DOWN
--UNIQUE, PK AND FK CONSTRAINTS IMPLICITLY GENERATE INDICES
CREATE INDEX MYNEWINDEX
ON ALBUM(ARTISTID); --OR ASC;
/*cursors: A VIEW STORED IN A LOCAL VARIABLE; A POINTER TO A SECTION
OF A TABLE/RESULTSET. It must be opened, can be looped through,
must be closed, and every sql statement generates a curson.
Allows PL/SQL to interact w/ SQL*/
--Implicit cursors
--DQL
--SELECT * FROM POKEMON;

/*SYSTEM REFERENCE CURSORS: ALREADY THERE FOR US TO USE
EXPLICIT CURSORS:
CUR S = SELECT * FROM POKEMON;
SELECT ID FROM S;
GOOD FOR FORMATTING OUR OUTPUT*/