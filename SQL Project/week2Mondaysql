--SELECT * FROM EMPLOYEE;

/*  Query Makeup

SELECT [COLUMNLIST] <- REQUIRED
FROM [TABLELIST <- REQUIRED
WHERE [CONDITION1] AND [CONDITION2]..
GROUP BY [COLUMNLIST]   <- GROUP THE RESULTSET. WIDE TO NARROW
                        <- AGGREGATAE FUNCTIONS
HAVING [CONDITION]  <- USED WITH THE GROUP BY CLAUSE IN A QUERY
                    TELLS THE GROUP BY WHICH GROUPS TO INCLUDE
                    IN THE OUTPUT
                    <- HAVING IS TO GROUP BY WHERE IS TO SELECT
                    <- AGGREGATE
ORDER BY [COLUMNLIST]   <- ASC IS DEFAULT, DESC TO REVERSE
*/
SELECT COUNT(EMPLOYEEID), COUNTRY, CITY
FROM EMPLOYEE
GROUP BY COUNTRY, CITY
HAVING COUNT(EMPLOYEEID) > 1;

/* CREATE A SEQUENCE
-CREATE OR REPLACE [Seq name]
-MINVALUE[value]
-MAXVALUE[value]
-START WITH [value]
-INCREMENT BY [value]
-CACHE [value];
*/

CREATE SEQUENCE MYTESTSEQ
MINVALUE 100
MAXVALUE 10000
START WITH 5000
INCREMENT BY -5
CACHE 20;

SELECT MYTESTSEQ.NEXTVAL FROM DUAL;
--INSERT INTO STUDENT(ID,NAME,SCHOOL_ID) VALUES (MYTESTSEQ.NEXTVAL,BOBBY,134);

--A VIEW TO KILL
--A VIEW IS A SAVED SELECT STATEMENT (BASICALLY)
CREATE VIEW MYVIEW2
AS SELECT TITLE AS A_LIST_OF_STUFF FROM ALBUM
UNION
SELECT NAME FROM ARTIST;

SELECT A_LIST_OF_STUFF FROM MYVIEW2
WHERE A_LIST_OF_STUFF LIKE 'T%';

/* INDEX
-APPLY TO A COLUMN TO SPEED UP SEARCH BY ENFORCING A PHYSICAL
IN-MEMORY ORDER OF ROWS
-SEARCHES BECOME FASTER, BUT INSERT/DELETE ARE SLOWED DOWN
-UNIQUE, PK AND FK CONSTRAINTS IMPLICITLY GENERATE INDICES
*/
CREATE INDEX MYNEWINDEX
ON ALBUM(ARTISTID);

/* CURSORS
-VIEW STORED IN A LOCAL VARIABLE
-A POINTER TO A SECTION OF A TABLE/RESULT SET
-IT MUST BE OPENED
-IT CAN BE LOOPED THROUGH
-IT MUST BE CLOSED
-EVERY SQL STATEMENT GENERATES A CURSOR, WHICH ALLOWS PL/SQL TO
INTERACT WITH SQL
**IMPLICIT CURSORS**
-DQL ==> SELECT * FROM POKEMON;
-SYSTEM REFERENCE CURSORS ARE ALREADY THERE FOR US TO USE
**EXPLICIT CURSORS**
CUR S = SELECT * FROM POKEMON;
SELECT ID FROM S;
GOOD FOR...?
*/

/* TRIGGERS
-EVENT LISTENER FOR A DB
-CAN SET ON DML STATEMENTS TO DO SOMETHING WHEN ROW IS CHANGED,
INSERTED, OR DELETED
-BEFORE OR AFTER ETC.
*/
--REFER TO BEAR FILE FOR EXAMPLE!!

/* FUNCTIONS
-BLOCK OF CODE THAT WE CAN EXECUTE
-MUST RETURN ONE AND ONLY ONE VALUE
-CAN HAVE 0+ MANY PARAMETERS
AND FUNCTIONS CAN CALL OTHER FUNCTIONS
-CAN NOT CALL STORED PROCEDURES,
TRANSACTIONS, OR DML
*/
CREATE OR REPLACE FUNCTION CALC_TAX
(T_ID IN NUMBER, TAX IN NUMBER)
RETURN NUMBER AS
TOTAL_PRICE NUMBER (10,2);
BEGIN
    SELECT UNITPRICE INTO TOTAL_PRICE
    FROM TRACK WHERE TRACKID = T_ID;
    RETURN TOTAL_PRICE + (TOTAL_PRICE*TAX);
END;
/
--USE THE FUNCTION!
SELECT CALC_TAX(2921, 0.06) FROM DUAL;

--CLASSWORK EXAMPLE 1
CREATE OR REPLACE FUNCTION GET_PHONE_NUMBER
(C_ID IN NUMBER)
RETURN VARCHAR2 AS
PHONE_NUMBER VARCHAR2(60); -- PARENTHESIS JUST SPECIFIES PRECISION. 10 SPACES, 2 DECIMAL PLACES
CUS_NAME VARCHAR2(40);
BEGIN
   SELECT PHONE INTO PHONE_NUMBER --COLUMNS FROM TRACK TABLE
   FROM CUSTOMER WHERE CUSTOMERID = C_ID;
   SELECT FIRSTNAME || ' ' || LASTNAME INTO CUS_NAME FROM CUSTOMER WHERE CUSTOMERID = C_ID;

   RETURN 'Customer ' || CUS_NAME || '''s phone number is ' || PHONE_NUMBER;
END;
/

SELECT GET_PHONE_NUMBER(20) FROM DUAL;

--CLASSWORK EXAMPLE 2
CREATE OR REPLACE TYPE CUSTOMER_NAME FORCE IS OBJECT(FIRSTNAME VARCHAR2(20),LASTNAME VARCHAR2(20));
/
CREATE OR REPLACE TYPE CUSTOMER_TABLE IS TABLE OF CUSTOMER_NAME;
/
CREATE OR REPLACE FUNCTION CUSTOMER_LIST (SUPPORTREPID1 NUMBER)
RETURN customer_TABLE AS
   L_CUSTOMER_TABLE CUSTOMER_TABLE :=CUSTOMER_TABLE();
   N INTEGER :=0;
BEGIN
   FOR I IN (SELECT FIRSTNAME,LASTNAME FROM CUSTOMER WHERE SUPPORTREPID=SUPPORTREPID1)
   LOOP
       L_CUSTOMER_TABLE.EXTEND;
       N:=N+1;
       L_CUSTOMER_TABLE(N) := CUSTOMER_NAME(I.FIRSTNAME,I.LASTNAME);
       END LOOP;
   RETURN L_CUSTOMER_TABLE;
END;
/
SELECT * FROM TABLE(CUSTOMER_LIST(5));
CREATE SEQUENCE MYSEQ;

/* STORED PROCEDURES
-DO NOT AND CANNOT RETURN A VALUE
-SUPPORT MULTIPLE IN, OUT, AND IN/OUT PARAMETERS
-STORED PROCEDURES CAN CALL OTHER STORED PROCEDURES, BUT NOT FUNCTIONS
-TRANSACTIONS ARE OKAY, SO IS DML
-DDL IS NOT OKAY
*/
CREATE OR REPLACE PROCEDURE BEARPRO
(CAVE_NAME IN VARCHAR2, BEAR_NAME IN VARCHAR2,
BEAR_BIRTHDATE IN DATE, CAVE_ID IN NUMBER)
AS
BEGIN
    INSERT INTO CAVE VALUES(MYSEQ.NEXTVAL, CAVE_NAME, DEFAULT);
    INSERT INTO BEEHIVE VALUES(MYSEQ.NEXTVAL, 50);
    INSERT INTO BEAR VALUES
    (MYSEQ.NEXTVAL, 1, BEAR_NAME, BEAR_BIRTHDATE, 200, CAVE_ID);
    COMMIT;
END;
/

EXECUTE BEARPRO('WHOO', 'CHARLIE', '14-FEB-1992', 5);
SELECT * FROM BEAR;
SET SERVEROUTPUT ON;

CREATE OR REPLACE PROCEDURE GET_ALL_ALBUMS
(S OUT SYS_REFCURSOR)
IS
BEGIN
    OPEN S FOR
    SELECT ALBUMID, TITLE FROM ALBUM;
END;
/

--MAKING AND USING A CURSOR
DECLARE
S SYS_REFCURSOR;
ALBUM_ID ALBUM.ALBUMID%TYPE; --SET ALBUM_ID TO WHATEVER DATA TYPE ALBUMID IS
ALBUM_NAME ALBUM.TITLE%TYPE;
BEGIN
    GET_ALL_ALBUMS(S);
    LOOP
    FETCH S INTO ALBUM_ID, ALBUM_NAME;
    EXIT WHEN S%NOTFOUND; --BREAK OUT OF LOOP WHEN NO MORE ROWS ARE AVAILABLE
    DBMS_OUTPUT.PUT_LINE(ALBUM_ID||' IS CURRENT ID, '||ALBUM_NAME||' IS CURRENT NAME');
    END LOOP
    CLOSE;
END;
/